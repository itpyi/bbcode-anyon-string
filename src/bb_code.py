from __future__ import annotations

from dataclasses import dataclass, field
from itertools import product
from typing import List, Optional, Sequence, Tuple, Union

import sympy as sp

ExprLike = Union[str, sp.Expr]


def _to_expr(expr: ExprLike, x: sp.Symbol, y: sp.Symbol) -> sp.Expr:
    if isinstance(expr, sp.Expr):
        return expr
    return sp.sympify(expr, locals={"x": x, "y": y})


@dataclass
class BBCode:
    """Bivariate bicycle (BB) code over R = F_2[x^{±1}, y^{±1}].

    Notes:
        - We model Laurent polynomials as SymPy expressions in x, y
          (negative exponents are allowed).
    """

    f: ExprLike
    g: ExprLike
    x: sp.Symbol = sp.Symbol("x")
    y: sp.Symbol = sp.Symbol("y")
    _groebner_cache: Optional[sp.GroebnerBasis] = field(default=None, init=False)
    _gens_cache: Optional[Tuple[sp.Symbol, sp.Symbol, sp.Symbol, sp.Symbol]] = field(
        default=None, init=False
    )
    _period_cache: Optional[Tuple[int, int]] = field(default=None, init=False)
    _basis_cache: Optional[List[sp.Expr]] = field(default=None, init=False)

    def __post_init__(self) -> None:
        self.f = _to_expr(self.f, self.x, self.y)
        self.g = _to_expr(self.g, self.x, self.y)

    def _groebner(self) -> Tuple[sp.GroebnerBasis, Tuple[sp.Symbol, sp.Symbol, sp.Symbol, sp.Symbol]]:
        if self._groebner_cache is None or self._gens_cache is None:
            G, gens = _construct_groebner(self.f, self.g)
            self._groebner_cache = G
            self._gens_cache = gens
        return self._groebner_cache, self._gens_cache

    def anyon_space(self) -> List[sp.Expr]:
        """Compute a monomial basis for the anyon space R/(f, g)."""
        if self._basis_cache is not None:
            return list(self._basis_cache)

        G, gens = self._groebner()

        bounds = _variable_bounds(G, gens)
        if bounds is None:
            raise ValueError("Ideal (f, g) is not zero-dimensional; anyon space is infinite.")

        leading = [_leading_monomial_exponent(p, G.order) for p in G.polys]
        basis: List[sp.Expr] = []
        for exps in product(*(range(b) for b in bounds)):
            if any(_divides(lm, exps) for lm in leading):
                continue
            mon = sp.Integer(1)
            for sym, exp in zip(gens, exps):
                if exp:
                    mon *= sym**exp
            basis.append(mon)

        x, y, xinv, yinv = gens
        normalized = [_normalize_laurent_expr(mon, x, y, xinv, yinv) for mon in basis]
        self._basis_cache = normalized
        return list(normalized)

    def anyon_period(self, max_steps: int | None = None, recompute: bool = False) -> Tuple[int, int]:
        """Compute anyon periods (Lx, Ly) for this BB code."""
        if self._period_cache is not None and not recompute and max_steps is None:
            return self._period_cache

        G, gens = self._groebner()
        bounds = _variable_bounds(G, gens)
        if bounds is None:
            raise ValueError("Ideal (f, g) is not zero-dimensional; anyon periods are infinite.")

        used_default_steps = max_steps is None
        if used_default_steps:
            basis = self.anyon_space()
            max_steps = max(1, 2 ** len(basis) - 1)

        x, y, *_ = gens

        def normal_form(expr: sp.Expr) -> sp.Expr:
            return G.reduce(expr)[1]

        def element_order(symbol: sp.Symbol) -> int:
            cur = normal_form(symbol)
            for L in range(1, max_steps + 1):
                if normal_form(cur + 1) == 0:
                    return L
                cur = normal_form(cur * symbol)
            raise ValueError("Exceeded max_steps while searching for period.")

        periods = (element_order(x), element_order(y))
        if used_default_steps and not recompute:
            self._period_cache = periods
        return periods

    def anyon_string(
        self,
        vector: Sequence[int],
        m: int,
        n: int,
    ) -> Tuple[sp.Expr, sp.Expr]:
        """Compute (s, t) such that s f + t g = a (x^{m Lx} y^{n Ly} + 1)."""
        basis = self.anyon_space()
        if len(basis) != len(vector):
            raise ValueError("basis and vector must have the same length")

        G, gens = self._groebner()
        x, y, xinv, yinv = gens

        a = sp.Integer(0)
        for coeff, mon in zip(vector, basis):
            if int(coeff) % 2 == 1:
                a += mon

        a = _laurent_to_polynomial(a, x, y, xinv, yinv)
        Lx, Ly = self.anyon_period()

        mon = _laurent_power(x, xinv, m * Lx) * _laurent_power(y, yinv, n * Ly)
        target = sp.expand(a * (mon + 1))

        quotients, remainder = G.reduce(target)
        if remainder != 0:
            raise ValueError("Target is not in the ideal generated by (f, g).")

        s = quotients[0]
        t = quotients[1]
        s_norm = _normalize_laurent_expr(s, x, y, xinv, yinv)
        t_norm = _normalize_laurent_expr(t, x, y, xinv, yinv)
        return s_norm, t_norm

def _laurent_to_polynomial(
    expr: sp.Expr, x: sp.Symbol, y: sp.Symbol, xinv: sp.Symbol, yinv: sp.Symbol
) -> sp.Expr:
    expr = sp.expand(expr)

    def repl_pow(e: sp.Expr) -> sp.Expr:
        if isinstance(e, sp.Pow):
            base, exp = e.as_base_exp()
            if base == x and exp.is_integer and exp < 0:
                return xinv ** (-exp)
            if base == y and exp.is_integer and exp < 0:
                return yinv ** (-exp)
        return e

    return sp.expand(expr.replace(lambda e: isinstance(e, sp.Pow), repl_pow))


def _construct_groebner(
    f: ExprLike, g: ExprLike
) -> Tuple[sp.GroebnerBasis, Tuple[sp.Symbol, sp.Symbol, sp.Symbol, sp.Symbol]]:
    x, y, xinv, yinv = sp.symbols("x y xinv yinv")
    f_expr = _to_expr(f, x, y)
    g_expr = _to_expr(g, x, y)
    f_poly = _laurent_to_polynomial(f_expr, x, y, xinv, yinv)
    g_poly = _laurent_to_polynomial(g_expr, x, y, xinv, yinv)

    gens = (x, y, xinv, yinv)
    relations = [x * xinv - 1, y * yinv - 1]
    G = sp.groebner([f_poly, g_poly, *relations], *gens, order="lex", domain=sp.GF(2))
    return G, gens


def _leading_monomial_exponent(poly: sp.Poly, order: str) -> Tuple[int, ...]:
    return poly.LM(order=order)


def _divides(lm: Sequence[int], mon: Sequence[int]) -> bool:
    return all(m >= l for m, l in zip(mon, lm))


def _variable_bounds(
    groebner: sp.GroebnerBasis, gens: Sequence[sp.Symbol]
) -> Tuple[int, ...] | None:
    bounds = [None] * len(gens)
    order = groebner.order
    for poly in groebner.polys:
        lm = _leading_monomial_exponent(poly, order)
        nonzero = [i for i, e in enumerate(lm) if e != 0]
        if len(nonzero) == 1:
            idx = nonzero[0]
            exp = lm[idx]
            if bounds[idx] is None or exp < bounds[idx]:
                bounds[idx] = exp
    if any(b is None for b in bounds):
        return None
    return tuple(int(b) for b in bounds)


def _laurent_power(symbol: sp.Symbol, inv_symbol: sp.Symbol, exp: int) -> sp.Expr:
    return symbol**exp if exp >= 0 else inv_symbol ** (-exp)


def _normalize_laurent_expr(
    expr: sp.Expr,
    x: sp.Symbol,
    y: sp.Symbol,
    xinv: sp.Symbol,
    yinv: sp.Symbol,
) -> sp.Expr:
    expr = sp.expand(expr)
    terms = expr.as_ordered_terms() if isinstance(expr, sp.Add) else [expr]
    monomials: dict[Tuple[int, int], int] = {}

    for term in terms:
        coeff, monomial = term.as_coeff_Mul()
        if int(coeff) % 2 == 0:
            continue

        powers = monomial.as_powers_dict()
        x_exp = int(powers.get(x, 0)) - int(powers.get(xinv, 0))
        y_exp = int(powers.get(y, 0)) - int(powers.get(yinv, 0))
        key = (x_exp, y_exp)
        monomials[key] = (monomials.get(key, 0) + 1) % 2

    result = sp.Integer(0)
    for (x_exp, y_exp), coeff in monomials.items():
        if coeff % 2 == 0:
            continue
        mon = sp.Integer(1)
        mon *= x**x_exp if x_exp >= 0 else x**x_exp
        mon *= y**y_exp if y_exp >= 0 else y**y_exp
        result += mon

    return sp.expand(result)


